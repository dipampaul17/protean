[
  {
    "source": "github:codesearch",
    "url": "https://github.com/JohnEarnest/Mako/blob/c17b64b641049d698e30bacf055f7bf317d7c205/docs/postmortem-Deep.md",
    "title": "postmortem-Deep.md",
    "content": "Deep: A Postmortem\n==================\n\nAs I begin to make more sophisticated games for the MakoVM platform, I thought it would be a good idea to try to record some of my experiences, both from the perspective of programming in Forth and lessons learned in game design.\n\nBackground\n----------\nWith Deep, I set out to create an arcade-style action game in the vein of Space Invaders. I was also deeply inspired by the minimalist but impactful \"storytelling mechanics\" of Missile Command, so I wanted to try to capture some of that spirit. In an arcade game, I think the main storytelling element that must be included is a setting, which provides framing for what the game will communicate to the player. The way the rules of the game cause elements to act can express ideas within this context.\n\nAnd so the game begins with a man in a small boat, in the middle of a deep ocean. I spent a lot of time building a nice animated background that sets the scene before I built any significant gameplay logic, which was quite satisfying.\n\nEntities\n--------\nStructurally, I tried some different ideas with this game. The core is what I call the 'Entity' system. In previous games I'd always allocated sprite registers statically. Sprite 0 for the player, sprite 1 for a door, sprites 10-30 for enemies, etc. This becomes fairly clumsy for complex scenes, since you have to keep track of which registers are free for various types of objects and you may not make the best use of the available space. The alternative is to allocate the registers dynamically via a malloc/free-like mechanism. Here's a simplified version of the relevant words:\n\n\t:array types    257 0\n\t:array sprites 1024 0\n\t:array bogus      4 0\n\t\n\t: valid ( id -- flag )\n\t\ttypes + @ if true else false then\n\t;\n\t\n\t: alloc ( -- n )\n\t\t0 256 types + !\n\t\t0 loop\n\t\t\tdup valid -if exit then\n\t\t\t1 +\n\t\tagain\n\t;\n\t\n\t: free ( id -- )\n\t\tdup types + 0 swap !\n\t\tsprite@     0 swap !\n\t;\n\nThe `types' array is used to keep track of the object type associated with the corresponding sprite register. A value of zero indicates a free register. Rather than coming up with a table of unique IDs and having a dispatch loop elsewhere to link objects up with their game logic I just store function pointers in the type table. They're consistent and unique, so they work as well as anything for an identifier.\n\nIn a normal malloc, I might need to worry about what happens when I run out of space. In games, failing to spawn an entity is often not a big deal- who cares if the screen is full of enemies and I can't create all five bubble sprites for my particle effect? Rather than forcing code throughout the game engine to worry about handling this error condition, I make the sprite table and the type table one entry larger than they need to be. If allocating a real sprite register fails, the index of this 'bogus' sprite register is returned. Game logic that cares about getting a valid register can check for the error condition and deal with it, while more forgiving scripts can harmlessly write to this slot.\n\nHigher-Order Functions\n----------------------\nI also wanted to try to use as few loops as possible in this game. I've been working my way through _The Structure and Interpretation of Computer Programs_  (SICP) and I'm really seeing the value of abstracting patterns like iteration and dispatch. Forth doesn't have lexical scope or closures, but you can get pretty far on just function pointers.\n\n\t: whoever ( 'filter 'func -- )\n\t\t>r >r first-e\n\t\tloop\n\t\t\tdup i exec over valid and\n\t\t\tif dup j exec then\n\t\t\t1 + dup last-e <=\n\t\twhile\n\t\tdrop r> r> 2drop\n\t;\n\n\t: count+      drop swap 1 + swap            ;\n\t: count       0 swap ' count+ whoever       ; ( 'filter -- )\n\t: always      drop true                     ;\n\t: apply-type  dup types + @ exec            ;\n\t: think       ' always ' apply-type whoever ;\n\n`whoever` is the single end-all be-all word that iterates over valid entities and does something to them. It incorporates a filter because I often want to work with a subset of the objects in the game. Think of `whoever` as a combination of filter() and map() from SICP.\n\nCounting the number of entities which match a predicate and evaluating the game logic for all valid entities falls out very cleanly. Definitions like `always` suggest that working with higher-order functions like this can benefit from having an anonymous function syntax for throwaway predicates and helpers- definitely something worth considering for the future.\n\nOne thing I was a little unsatisified with about `count` is the fact that it's actually very tightly coupled with the way `whoever` manipulates the stack. `whoever` cannot be treated as a black box, since we want to keep a running total floating around between the stack arguments it uses. If I'd needed to keep track of more than one value for `count`'s purposes, the solution would need to become more invasive. Passing individual values around on the stack seems to lead to this sort of abstraction problem pretty frequently- I think object-oriented concatenative languages like PostScript and Factor have a big advantage in this area. If you can bundle an arbitrary number of values together as one 'thing', you can write generic functions which don't care about the datatypes they manipulate. In Forth I think the best alternative is trying a C-like technique of allocating structures on the stack and passing a pointer to them along to 'deeper' functions. Perhaps there's some kind of syntactic sugar I can build which will ease the process?\n\nEntity Scripting\n----------------\nNormally entities are controlled by some sort of state machine- game objects transfer between states as they go about their animations, experience stimuli and get exploded. In the past I might've given entities a field which indicates their current state and written a branching dispatch structure like a case block to choose which behaviors should be carried out.\n\nI already have a better mechanism for this, though. Why do a bunch of checks and branches every time my entities act when I can simply remap the function pointer in their 'type' field? In effect, I've turned the state machine inside-out by letting the states drive the conditions rather than the other way around. I also get the side benefit that entities can very easily transform into other types of entities. Check out how nicely this works:\n\n\t: menace\n\t\t32 wave-time\n\t\tsprite@ .sprite-t dup @ 1 xor swap !\n\t;\n\n\t: seek-player\n\t\tdup can-capsize if capsize then\n\t\tspeed @ 2 / wave-time\n\t\tdup py 40 > if dup sprite@ .sprite-y dec@ then\n\t\tdup px player px < if 2 else -2 then\n\t\tover sprite@ .sprite-x +@\n\t\tmenace\n\t;\n\n\t: swim\n\t\tdup py 64 < if ' seek-player type! exit then\n\t\t4 wave-time\n\t\tdirection @ over sprite@ .sprite-x +@\n\t\t\tspeed @ wave-time\n\t\tdup sprite@ .sprite-y dec@\n\t\tmenace\n\t;\n\nAn entity that is swimming can turn into an entity that seeks the player with a simple `' seek-player type!`- the state transitions are extremely clear to an observer. By using this type of organization, the previously discussed higher-order functions and an opt-out condition checking style I was able to write virtually all entity logic without using loops or nesting if statements. Now that's clean!\n\nYou may have noticed the `wave-time` function there. Remember how I started the project by building an animated background with rolling waves? As it so happens, entities frequently have use for a global timer to control their animations and movement. The waves need one too, and it has a longer cycle than virtually any other timer in the game. Co-opting the system for entity logic was natural, so I built a helper word which could be used to exit an entity script early based on some cyclic period of the global timer. A+ for code reuse, but if I was doing it again from scratch (or my next game) I'd build a global timer from the start and give it a better name.\n\nAt the end of the day, I was very happy with my main loop:\n\n\t: main\n\t\treset-game\n\t\tloop\n\t\t\tmove-player\n\t\t\tfire\n\t\t\twaves\n\t\t\tstorm\n\t\t\tbounce\n\t\t\tdraw-score\n\t\t\tspawn-crab\n\t\n\t\t\t' is-monster count -if spawn-wave then\n\t\t\tended @ gameover @ keys key-a and and and if reset-game then\n\t\n\t\t\tthink\n\t\t\tsync\n\t\tagain\n\t;\n\nIt comes pretty close to the goal of describing what needs to happen in a readable, high-level fashion which glosses over all the unimportant details. The main routines don't really depend on one another to function properly and could be re-ordered freely, indicating a good separation of concerns.\n\nEmergent Game Design\n--------------------\nI started out with the idea of building a game that communicated some kind of narrative without using words, and I think the places I succeeded were almost entirely accidental.\n\nWhen I writing the code to spawn waves of enemies, I quite straightforwardly said \"when there are no enemies alive, spawn the next wave\". When I later added crabs which spawn randomly and add a little chaos to the strategy of gameplay I didn't initially realize that as written a crab would always spawn before the first wave. This meant that the game would start with a lone crab attacking the player, and if he was destroyed a horde of his allies from the deep would immediately appear, as if to avenge his death. Genius! Not only does this slow start give the player a brief chance to get used to the basic game mechanics, it also raises a question- does the player bring inevitable destruction upon themselves? Who is really the protagonist here?\n\nPerhaps not as deep and socially-aware as Missile Command's statement about nuclear proliferation and hard real-life decisionmaking, but I'll settle for anything thought provoking.\n\nGame design lesson: pay attention to unintended consequences and bugs. As Bob Ross would say, we don't have mistakes here, we just have happy accidents.\n\nSummary\n-------\nDynamically allocating sprite registers via the entity system is a good abstraction. Reserving \"bogus buffers\" and failing silently can prevent error checking code from leaking out into main game logic. Factoring loops and conditionals into utility words and providing the 'loop bodies' via function pointers can lead to very terse, clean code. Inverting the usual structure of a state machine results in code which more closely resembles the transition diagram, lessening the maintenance problems traditionally associated with using state machines. Sometimes great design ideas can arise completely by accident- it's important to pay attention to bugs and try to use them to the game's favor.",
    "timestamp": "2025-05-23T16:23:22.259748",
    "tags": [],
    "severity": "medium",
    "services_affected": [
      "web"
    ],
    "root_cause": null,
    "resolution_time": null,
    "infrastructure_components": [
      "aws",
      "azure",
      "jenkins"
    ],
    "failure_pattern": null,
    "timeline_events": [],
    "blast_radius": "global",
    "detection_time": null,
    "mitigation_actions": [],
    "quality_score": 0.49
  },
  {
    "source": "github:codesearch",
    "url": "https://github.com/dastergon/postmortem-templates/blob/ebdaf8f122cf1d9f5c2983b37861be038c9acc89/templates/postmortem-template-michael.kehoe.md",
    "title": "postmortem-template-michael.kehoe.md",
    "content": "> Template from: [Michael Kehoe](https://michael-kehoe.io/post/postmortem-template/)\n\n# Postmortem Template\n\n### Summary\n| Incident Summary   |   |                       |   |\n|--------------------|---|-----------------------|---|\n| Incident Number    |   | Incident Severity     |   |\n| Postmortem Date    |   | War-room Required     |   |\n| SRE Lead           |   | Developer Lead        |   |\n| Incident Mgmt Lead |   | Chaos Eng Preventable |   |\n| Postmortem Lead    |   | Recording             |   |\n\n### Postmortem Attendees\n| Name | Role | In attendence |\n|------|------|---------------|\n|      |      |               |\n|      |      |               |\n|      |      |               |\n\n### Incident Timing\n| Start Time      |       | Incident Detected By(User-reported/ Ad-hoc monitoring/ Alerting system) |      |\n|-----------------|-------|-------------------------------------------------------------------------|------|\n| Detection Time  |       | Time to Detect (TTD)                                                    |      |\n| Mitigation Time |       | Time to Mitigate (TTM)                                                  |      |\n| Resolution Time |       | Time to Resolve (TTR)                                                   |      |\n\n### Incident Timeline\n| Date/Time | Who/What | Action/ Impact |\n|-----------|----------|----------------|\n|           |          |                |\n|           |          |                |\n|           |          |                |\n\n### Impact\n\n#### End User Impact\n\n#### Infrastructure Impact\n\n#### Productivity Impact\n\n### What caused the incident?\n\n#### Trigger(s)\n\n#### Process Breakdown(s)\n\n#### Root Cause(s)\n\n### Mitigation & Resolution\n\n### Open Questions\n| Person            | Question/ Answer |\n|-------------------|------------------|\n| Q (who): A (who): |                  |\n| Q (who): A (who): |                  |\n| Q (who): A (who): |                  |\n\n### Lessons Learnt\n\n#### What went well\n\n#### What went badly\n\n#### Where did we get lucky\n\n### Action Items & Followups\n| Action Item | Type (Mitigate/ Prevent/ Process/ Other) | Who | Priority | Bug # | Due Date |\n|-------------|------------------------------------------|-----|----------|-------|----------|\n|             |                                          |     |          |       |          |\n|             |                                          |     |          |       |          |\n|             |                                          |     |          |       |          |\n\n### Supporting Documents\n",
    "timestamp": "2025-05-23T16:23:22.671059",
    "tags": [],
    "severity": "high",
    "services_affected": [
      "web",
      "monitoring"
    ],
    "root_cause": null,
    "resolution_time": null,
    "infrastructure_components": [
      "prometheus",
      "grafana"
    ],
    "failure_pattern": "monitoring_blind_spot",
    "timeline_events": [],
    "blast_radius": "localized",
    "detection_time": null,
    "mitigation_actions": [],
    "quality_score": 0.8999999999999999
  },
  {
    "source": "github:codesearch",
    "url": "https://github.com/HarleyCoops/Math-To-Manim/blob/7130ed2c4278c585add6915306ba4967bccba0eb/MCPPostMortem.md",
    "title": "MCPPostMortem.md",
    "content": "# MCP Server Troubleshooting Guide\n\n## Overview\n\nThis guide documents the issues encountered with Model Context Protocol (MCP) servers in Cline/Claude and the steps taken to resolve them. The primary problem was that MCP servers were failing to connect, showing errors like \"spawn npx ENOENT\" in the MCP Servers panel.\n\n## Initial Problems\n\nThere were several issues that needed to be addressed:\n\n1. **JSON Syntax Errors**: The MCP configuration files had syntax errors that prevented proper parsing.\n2. **PATH Environment Variable**: The `npx` command wasn't accessible from the PATH when the MCP server tried to run it.\n3. **NPX Module Resolution**: There was an issue with how `npx` was trying to find the firecrawl-mcp package.\n\n## Step-by-Step Troubleshooting Process\n\n### 1. Fixing JSON Syntax Errors\n\nThe first issue was with the JSON syntax in the configuration files:\n\n**Original Cline MCP settings file** (with errors):\n```json\nmcpServers\": {\n    \"github.com/mendableai/firecrawl-mcp-server\": {\n      \"command\": \"npx\"\n      \"args\": [\"-y\" \"firecrawl-mcp\"]\n      \"env\": {\n        \"FIRECRAWL_API_KEY\": \"YOUR_API_KEY_HERE\"\n      }\n      \"disabled\": false\n      \"autoApprove\": []\n    }\n  }\n}\n```\n\nProblems:\n- Missing opening curly brace\n- Missing commas after each property\n- Missing comma in the args array\n\n**Fixed Cline MCP settings file**:\n```json\n{\n  \"mcpServers\": {\n    \"github.com/mendableai/firecrawl-mcp-server\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"firecrawl-mcp\"],\n      \"env\": {\n        \"FIRECRAWL_API_KEY\": \"YOUR_API_KEY_HERE\"\n      },\n      \"disabled\": false,\n      \"autoApprove\": []\n    }\n  }\n}\n```\n\n**Original Claude desktop config file** (with errors):\n```json\nmcpServers\": {}\n}\n```\n\nProblems:\n- Missing opening curly brace\n\n**Fixed Claude desktop config file**:\n```json\n{\n  \"mcpServers\": {}\n}\n```\n\n### 2. Addressing PATH Issues\n\nAfter fixing the JSON syntax, we encountered a \"spawn npx ENOENT\" error, indicating that the system couldn't find the `npx` command. We verified that Node.js and npm were installed:\n\n```\nnode -v  # Output: v20.18.0\nnpx -v   # Output: 10.8.2\n```\n\nWe found the location of the `npx` command:\n```\ndir \"C:\\Users\\chris\\AppData\\Roaming\\npm\\npx*\"\n```\n\nThis showed that `npx` was located at `C:\\Users\\chris\\AppData\\Roaming\\npm\\npx.cmd`.\n\nWe updated the MCP settings to use the full path to `npx.cmd`:\n```json\n{\n  \"mcpServers\": {\n    \"github.com/mendableai/firecrawl-mcp-server\": {\n      \"command\": \"C:\\\\Users\\\\chris\\\\AppData\\\\Roaming\\\\npm\\\\npx.cmd\",\n      \"args\": [\"-y\", \"firecrawl-mcp\"],\n      \"env\": {\n        \"FIRECRAWL_API_KEY\": \"YOUR_API_KEY_HERE\"\n      },\n      \"disabled\": false,\n      \"autoApprove\": []\n    }\n  }\n}\n```\n\n### 3. Resolving NPX Module Resolution Issues\n\nAfter updating to use the full path to `npx.cmd`, we encountered a new error:\n```\nError: Cannot find module 'C:\\Users\\chris\\AppData\\Roaming\\npm\\node_modules\\npm\\bin\\npx-cli.js'\n```\n\nThis indicated an issue with how `npx` was trying to find the firecrawl-mcp package. We verified that the firecrawl-mcp package was installed globally:\n```\nnpm list -g firecrawl-mcp  # Output: firecrawl-mcp@1.3.3\n```\n\nWe found the main entry point for the firecrawl-mcp package by examining its package.json:\n```\ndir \"C:\\Users\\chris\\AppData\\Roaming\\npm\\node_modules\\firecrawl-mcp\"\ntype \"C:\\Users\\chris\\AppData\\Roaming\\npm\\node_modules\\firecrawl-mcp\\package.json\"\n```\n\nWe confirmed that the script could run directly with Node.js:\n```\nnode \"C:\\Users\\chris\\AppData\\Roaming\\npm\\node_modules\\firecrawl-mcp\\dist\\index.js\"\n```\n\nThis gave an expected error about the missing FIRECRAWL_API_KEY environment variable, confirming that the script itself worked.\n\n## Final Solution\n\nThe ultimate solution was to bypass `npx` entirely and run the firecrawl-mcp script directly with Node.js:\n\n```json\n{\n  \"mcpServers\": {\n    \"github.com/mendableai/firecrawl-mcp-server\": {\n      \"command\": \"node\",\n      \"args\": [\"C:\\\\Users\\\\chris\\\\AppData\\\\Roaming\\\\npm\\\\node_modules\\\\firecrawl-mcp\\\\dist\\\\index.js\"],\n      \"env\": {\n        \"FIRECRAWL_API_KEY\": \"YOUR_API_KEY_HERE\"\n      },\n      \"disabled\": false,\n      \"autoApprove\": []\n    }\n  }\n}\n```\n\n## How to Apply the Fix\n\n1. Edit the MCP settings file:\n   - For Cline (VSCode extension): `c:\\Users\\chris\\AppData\\Roaming\\Cursor\\User\\globalStorage\\saoudrizwan.claude-dev\\settings\\cline_mcp_settings.json`\n   - For Claude Desktop app: `C:\\Users\\chris\\AppData\\Roaming\\Claude\\claude_desktop_config.json`\n\n2. Update the configuration to use the direct Node.js approach as shown above.\n\n3. Reload the application:\n   - For Cline (VSCode extension): Press Ctrl+Shift+P, type \"Developer: Reload Window\" and press Enter\n   - For Claude Desktop app: Close and reopen the application\n\n4. Click \"Retry Connection\" in the MCP Servers panel.\n\n## Lessons Learned\n\n1. **JSON Syntax is Critical**: Even small syntax errors in JSON configuration files can cause the entire configuration to fail.\n\n2. **PATH Environment Variables**: MCP servers may not have access to the same PATH environment variables as your terminal. Using absolute paths to executables is more reliable.\n\n3. **Direct Execution**: When troubleshooting complex command chains (like using `npx` to run a package), try running the target script directly to isolate issues.\n\n4. **Verify Each Component**: Test each part of the system independently to identify where the failure is occurring.\n\n## Troubleshooting Tips for Future MCP Issues\n\n1. Check the JSON syntax in your configuration files.\n2. Use absolute paths to executables rather than relying on PATH.\n3. Test running the MCP server script directly to see if it works.\n4. Check if all required environment variables are properly set.\n5. Look for error messages in the MCP Servers panel for clues about what's going wrong.\n\n## Additional Resources\n\n- [Model Context Protocol Documentation](https://modelcontextprotocol.github.io/docs/)\n- [FireCrawl MCP Server GitHub Repository](https://github.com/mendableai/firecrawl-mcp-server)\n",
    "timestamp": "2025-05-23T16:23:23.165971",
    "tags": [],
    "severity": "high",
    "services_affected": [
      "api",
      "web",
      "database"
    ],
    "root_cause": null,
    "resolution_time": null,
    "infrastructure_components": [],
    "failure_pattern": "configuration_drift",
    "timeline_events": [],
    "blast_radius": "global",
    "detection_time": null,
    "mitigation_actions": [],
    "quality_score": 0.72
  },
  {
    "source": "github:codesearch",
    "url": "https://github.com/kristinbranson/APT/blob/1c6fd1e0d5fd4d8b02cdf564b78fe982f2247854/matlab/PostProcPostMortem.m",
    "title": "PostProcPostMortem.m",
    "content": "%% input args\n\nDATASET = 'sh';\n\nswitch DATASET\n  case 'bub'\n    ppbasefile = 'ppbase.mat';\n    outdir = 'mftsbub_out_20181101T090301';\n\n    ppbase = load(ppbasefile);\n    lblfile = ppbase.lblfile;\n    ld = load(lblfile,'-mat');\n    hmdirs = ppbase.lblfilehmdirs;\n\n  case 'sh'\n    outdirs = {\n      'out_1_90_20181108T083201'\n      'out_91_719_20181109T194358'\n    };\n    \n    lblfile = '/groups/branson/bransonlab/apt/experiments/data/sh_trn4879_gtcomplete_cacheddata.lbl';\n    ld = load(lblfile,'-mat');\nend\n\n%% load results\n\ntic\n\nswitch DATASET\n  case 'bub'\n    ddres = dir(fullfile(outdir,'*.mat'));\n    nres = numel(ddres);\n    PAT = 'imov(?<iMov>[0-9]{2,2})_itgt(?<iTgt>[0-9]{2,2})_sfrm(?<frm0>[0-9]{6,6})_nfrm(?<nfrm>[0-9]{6,6}).mat';\n    res = cell(nres,1);\n    resMD = cell(nres,1);\n    for i=1:numel(ddres)\n      resnameS = ddres(i).name;\n      sMD = regexp(resnameS,PAT,'names');\n      fns = fieldnames(sMD);\n      for f=fns(:)',f=f{1};\n        sMD.(f) = str2double(sMD.(f));\n      end\n\n      resname = fullfile(outdir,resnameS);\n      res{i} = load(resname);\n      fprintf('Loaded %s\\n',resname);\n\n      assert(res{i}.targets==sMD.iTgt);\n      assert(strcmp(res{i}.hmdir,hmdirs{sMD.iMov}));\n      assert(isscalar(res{i}.allppobj));\n      pp = res{i}.allppobj{1};\n      if pp.N~=sMD.nfrm\n        warningNoTrace('res %s, pp.N=%d. probably truncated by trx start/endframe. resetting sMD.nfrm to %d.\\n',...\n          resnameS,pp.N,pp.N);\n        sMD.nfrm = pp.N;\n      end\n\n      % whoops GV\n      for ipt=pp.pts2run\n        xyHM = squeeze(pp.postdata.viterbi_grid.x(:,ipt,:));\n        xy = PostProcess.UntransformByTrx(xyHM,pp.trx,pp.heatmap_origin); \n        pp.postdata.viterbi_grid.x(:,ipt,:) = xy;\n      end\n\n      res{i} = pp;\n      resMD{i} = sMD;\n    end\n\n    res = cat(1,res{:});\n    resMD = struct2table(cell2mat(resMD));\n    \n  case 'sh'\n    resAgg = [];\n    hmdirAgg = [];\n    for i=1:numel(outdirs)\n      outdir = outdirs{i};\n      ddres = dir(fullfile(outdir,'*.mat'));\n      nres = numel(ddres);\n      res = cell(nres,1);\n      hmdir = cell(nres,1);\n      for i=1:nres\n        resnameS = ddres(i).name;\n        resname = fullfile(outdir,resnameS);\n        res{i} = load(resname);\n        fprintf('Loaded %s\\n',resname);\n\n        assert(isscalar(res{i}.allppobj));\n        hmdir{i} = res{i}.hmdir;\n        res{i} = res{i}.allppobj{1};\n      end\n\n      res = cat(1,res{:});\n\n      resAgg = cat(1,resAgg,res);\n      hmdirAgg = cat(1,hmdirAgg,hmdir);\n    end\n    \n    res = resAgg;\n    hmdir = hmdirAgg;\n    nres = numel(res);\n    \nend\n\nttoc = toc;\nfprintf(1,'Results loaded in %d s\\n',round(ttoc));\n\n%% make tMFTall\nswitch DATASET\n  case 'bub'\n    tMFTall = [];\n    for ires=1:nres\n      t = res(ires).tblMFT;\n      t.iMov = repmat(resMD.iMov(ires),height(t),1);\n      t.iTgt = repmat(resMD.iTgt(ires),height(t),1);\n      assert(t.frm(1)==resMD.frm0(ires));\n\n      tMFTall = [tMFTall;t];\n    end\n    tMFTall = tMFTall(:,{'iMov' 'frm' 'iTgt'});\n    tMFTall.Properties.VariableNames{1} = 'mov';\n    pts2run = res(1).pts2run;\n    \n    tGT = Labeler.lblFileGetLabels(ld);\n    assert(strcmp(tGT.Properties.VariableNames{1},'mov'));\n    lbl = ld;\n    npts = lbl.cfg.NumLabelPoints;\n\n  case 'sh'\n    \n    tGT = Labeler.lblFileGetLabels(ld);\n    assert(strcmp(tGT.Properties.VariableNames{1},'mov'));\n    tGT = tGT(:,1:4);\n    tGT.p = tGT.p(:,[6:10 16:20]);\n    lbl = ld;\n    npts = lbl.cfg.NumLabelPoints;\n    \n    MOVFILE = '/groups/branson/bransonlab/apt/tmp/postproc/sh/shtrn719_vw2_movs.txt';\n    movs = readtxtfile(MOVFILE);\n    szassert(movs,size(lbl.movieFilesAll(:,2)));\n    movdirs = cellfun(@fileparts,movs,'uni',0);\n%     \n%     tGT.iMov = tGT.mov;\n%     tGT.mov = movs(tGT.mov);\n    \n    hmdirimov = nan(nres,1);\n    tMFTall = [];\n    for ires=1:nres\n      hmd = hmdir{ires};\n      idx = strfind(hmd,'/hmap/');\n      idx = idx+numel('/hmap/')-1;\n      hmd = hmd(idx:end);\n      hmdMovDir = fileparts(hmd);\n      \n      imov = find(strcmp(hmdMovDir,movdirs));\n      assert(isscalar(imov));\n      hmdirimov(ires) = imov;\n\n      n = res(ires).N;\n      t = table(repmat(imov,n,1),(1:n)',ones(n,1),...\n        'VariableNames',{'mov' 'frm' 'iTgt'});\n\n      tMFTall = [tMFTall;t];\n    end\n    pts2run = res(1).pts2run;\nend\n\n%% adjust for crops if nec\ntfcrop = false;\nswitch DATASET\n  case 'sh'\n    tfcrop = true;\n    CROPFILE = '/groups/branson/bransonlab/apt/tmp/postproc/sh/shtrn719_vw2_crops.txt';\n    crops = dlmread(CROPFILE);\n    szassert(crops,[numel(movs) 4]);\nend\n  \n%% aggregate postdatas\nalgs = fieldnames(res(1).postdata);\nnalg = numel(algs);\npdall = struct();\n\nDAMPS = 0:.05:1;\nnDamp = numel(DAMPS);    \n\nNall = sum([res.N]);\nfprintf('Nall=%d\\n',Nall);\n\nfor ialg=1:nalg\n  alg = algs{ialg};  \n  pdalg = struct();\n  fprintf(1,'### Alg is %s\\n',alg);\n  \n  for ires=1:nres\n    if mod(ires,10)==0\n      disp(ires);\n    end\n    \n    pp = res(ires);\n    pdalgI = res(ires).postdata.(alg);\n    if isfield(pdalgI,'score') && strncmp(alg,'viterbi',7) && size(pdalgI.score,1)~=1\n      pdalgI.score = reshape(pdalgI.score,[1 size(pdalgI.score)]);\n    end\n    \n    % compute derived stats\n    x = pdalgI.x; % [n x npt x 2]\n    \n    if tfcrop\n      imov = hmdirimov(ires);\n      roi = crops(imov,:);\n      x(:,:,1) = x(:,:,1)+roi(1)-1;\n      x(:,:,2) = x(:,:,2)+roi(3)-1;\n    end\n    \n    v = diff(x,1,1); % v(i,ipt,:) gives (dx,dy) that takes you from t=i to t=i+1\n    v(end+1,:,:) = nan; % so v has same size as x, [n x npt x 2]\n    vmag = sqrt(sum(v.^2,3)); \n    a = diff(x,2,1); \n    a = cat(1,nan(1,pp.npts,2),a,nan(1,pp.npts,2));\n    % a(i,ipt,:) gives finite-diff accel, centered at t=i (using\n    % t=i-1,i,i+1)\n    amag = sqrt(sum(a.^2,3)); % (n-2) x npt\n\n    assert(isequal(size(x),size(v),size(a)));\n    assert(isequal(size(vmag),size(amag)));\n    \n    % compute x_pred using actual damping used\n    damp = pp.viterbi_dampen; \n    % at i; assume motion that took you from i-1->i continues to i+1\n    x_pred = nan(size(x));\n    x_pred(3:end,:,:) = x(2:end-1,:,:) + damp*v(1:end-2,:,:);\n    dx_pred = x-x_pred;\n    dx_pred_mag = sqrt(sum(dx_pred.^2,3)); % [n x npt]\n\n    assert(isequal(size(x),size(x_pred),size(dx_pred)));\n    szassert(dx_pred_mag,size(vmag));\n    \n    % compute x_pred using arbitrary damps\n    [n,npt,d] = size(x);\n    x_preddamps = nan(n,npt,d,nDamp);\n    x_preddamps(3:end,:,:,:) = x(2:end-1,:,:) + reshape(DAMPS,[1 1 1 nDamp]).*v(1:end-2,:,:); % at i; assume motion that took you from i-1->i continues to i+1 \n    dx_preddamps = x-x_preddamps;\n    dx_preddamps_mag = sum(dx_preddamps.^2,3); % [n x npt x 1 x nDamp]\n    dx_preddamps_mag = reshape(dx_preddamps_mag,[n npt nDamp]);\n    szassert(dx_preddamps,size(x_preddamps));\n    \n    pdalgI.x = x;\n    pdalgI.v = v;\n    pdalgI.vmag = vmag;\n    pdalgI.a = a;\n    pdalgI.amag = amag;\n    pdalgI.x_pred = x_pred;\n    pdalgI.dx_pred = dx_pred;\n    pdalgI.dx_pred_mag = dx_pred_mag;\n    pdalgI.x_preddamps = x_preddamps;\n    pdalgI.dx_preddamps = dx_preddamps;\n    pdalgI.dx_preddamps_mag = dx_preddamps_mag;\n\n    res(ires).postdata.(alg) = pdalgI; % we only added stuff to pdalgI\n    \n    assert(isequal(n,pp.N,size(x,1),size(v,1),size(vmag,1),size(a,1),size(amag,1),size(x_pred,1),size(dx_pred,1),size(dx_pred_mag,1),...\n      size(x_preddamps,1),size(dx_preddamps,1),size(dx_preddamps_mag,1)));\n\n    if ires==1\n      pdalg = pdalgI;\n      \n      % set this for all ires for this current alg\n      fldsExpand = fieldnames(pdalg);\n      if ismember('score',fldsExpand) && size(pdalg.score,1)==1\n        fldsExpand = setdiff(fldsExpand,'score');\n      end\n      \n      fprintf('Expanding fields: %s\\n',String.cellstr2CommaSepList(fldsExpand));\n      for f=fldsExpand(:)';f=f{1};\n        if isnumeric(pdalg.(f))          \n          pdalg.(f)(Nall,:) = nan;\n        elseif islogical(pdalg.(f))\n          pdalg.(f)(Nall,:) = false;\n        else\n          assert(false);\n        end\n      end\n      \n      pdalg.ires = zeros(Nall,1);\n      pdalg.ires(1:n) = 1;\n      \n      pdalgExpandCurrRow = n; % pdalg.(expandfld) is filled thru this row      \n    else\n      fns = fieldnames(pdalgI);\n      for f=fns(:)',f=f{1};\n        if ismember(f,fldsExpand)\n          pdalg.(f)(pdalgExpandCurrRow+1:pdalgExpandCurrRow+n,:) = reshape(pdalgI.(f),n,[]);\n        else\n          pdalg.(f) = cat(1,pdalg.(f),pdalgI.(f));\n        end\n      end\n      \n      pdalg.ires(pdalgExpandCurrRow+1:pdalgExpandCurrRow+n) = ires;\n      \n      pdalgExpandCurrRow = pdalgExpandCurrRow+n;\n    end\n    \n    switch DATASET\n      case 'bub'\n        assert(height(res(ires).tblMFT)==size(pdalgI.x,1));    \n    end\n  end\n  \n  assert(pdalgExpandCurrRow==Nall);\n  \n  pdall.(alg) = pdalg;  \nend\n\n\n\n%% GT\n[tf,loc] = tblismember(tGT,tMFTall,MFTable.FLDSID);\n%frmsGT = tGT.frm(tf);\nisampGT = loc(tf);\nnGT = nnz(tf);\nlposGT = reshape(tGT.p(tf,:),[nGT npts 2]);\nfprintf(1,'%d frmsGT.\\n',nGT);\n\nalgsAll = fieldnames(pdall);\ndxyAll = cell(0,1);\nfor alg=algsAll(:)',alg=alg{1}; %#ok<FXSET>\n  %[n x npts x (x/y) x nviews x nsets]\n  tpos = pdall.(alg).x(isampGT,:,:); % nGT x npts x d   \n  dxyAll{end+1,1} = tpos-lposGT;\nend\ndxyAll = cat(5,dxyAll{:});\n\ndxyAllPtsRun = dxyAll(:,pts2run,:,:,:);\n\n[hFig,hAxs] = GTPlot.ptileCurves(dxyAllPtsRun,...\n  'ptiles',[50 75 90],...\n  'setNames',algsAll,...\n  'ptNames',arrayfun(@(x)sprintf('pt%02d',x),pts2run,'uni',0),...\n  'createsubplotsborders',[.05 0;.15 .15]...\n  );\n\nim = zeros(60,40);\nI = {im};\nxyLbl = [25 45;25 30;25 15;15 15;15 30;15 45];\n\n% SEE Also GT+Damp below\n[hFig,hAxs] = GTPlot.bullseyePtiles(dxyAllPtsRun,I,xyLbl,...\n  'ptiles',[50 75 90],...\n  'setNames',algsAll,...\n  'lineWidth',2,...\n  'contourtype','ellipse');\n\n%% Jumpiness Hist -- ALL LUMPED\n% algs = fieldnames(pdall);\n% nAlgs = numel(algs);\n% npts2run = numel(pts2run)\n% dzall = []; % [n x npts2run x nalg]. magnitude of jump\n% \n% hFig = figure(11);\n% clf;\n% axs = mycreatesubplots(nAlgs,npts2run,[.1 .05]);\n% clrs = lines(npts2run);\n% \n% ALGMARKS = {'.' 'x' '^'};\n% for ialg=1:nAlgs\n%   alg = algs{ialg};\n%   x = pdall.(alg).x; % n x npt x d\n%   a = diff(x,2,1);\n%   amag = sqrt(sum(a.^2,3)); % (n-2) x npt\n%   \n%   for iipt=1:npts2run\n%     ipt = pts2run(iipt);\n%     ax = axs(ialg,iipt);\n%     axes(ax);\n%     histogram(amag(:,ipt),0:20);\n%   end\n%   \n%   ylabel(axs(ialg,1),alg,'fontweight','bold','interpreter','none');\n% end\n% \n% for iipt=1:npts2run\n%   linkaxes(axs(:,iipt));\n% end\n\n%% Jumpiness ptileplot\namag = []; % nsamp x npts2run x nalg\nfor ialg=1:nalg\n  alg = algs{ialg};\n  amagtmp = pdall.(alg).amag(:,pts2run,:); \n  amag = cat(3,amag,amagtmp);\nend\n% amagagg is [Nall x npts2run x nAlgs] with some nans at ends of segments\n% etc\n\nnpts2run = numel(pts2run);\nhFig = figure(15);\namagplot = reshape(amag,[Nall npts2run 1 1 nalg]);\n[hFig,hAxs] = GTPlot.ptileCurves(amagplot,...\n  'ptiles',[50 75 90],...\n  'hFig',hFig,...\n  'setNames',algsAll,...\n  'ptNames',arrayfun(@(x)sprintf('pt%02d',x),pts2run,'uni',0),...\n  'createsubplotsborders',[.05 0;.15 .15]...\n  );\n\n%% viterbi Basin\n\n% tGT = Labeler.lblFileGetLabels(ld);\n% assert(strcmp(tGT.Properties.VariableNames{1},'mov'));\n% lbl = ld;\n%%\n% if no thresh, then super-peaked distros in rescaled space and the central \n% y-val is indistinguishable from y=1. but using only larger vmags (above\n% thresh etc) looks better.\nVMAG_MINOKTHRESH = 3;\n\n[tf,loc] = tblismember(tGT,tMFTall,MFTable.FLDSID);\n%frmsGT = tGT.frm(tf);\nisampGT = loc(tf);\nnGT = nnz(tf);\nnpts = lbl.cfg.NumLabelPoints;\nlposGT = reshape(tGT.p(tf,:),[nGT npts 2]);\nfprintf(1,'%d frmsGT.\\n',nGT);\n\npdmi = pdall.maxdensity_indep;\nassert(max(pdmi.ires)==numel(res));\n\nlposGTuse = cell(npts2run,1); \n% lposGTuse{iipt} is nan(0,2); % [nuse x 2] labels\ntposGTuse = cell(npts2run,1);\n% tposGTuse{iipt} is nan(0,2,3); % [nuse x 2 x 3] tracked locs (maxdensity). 4th dim: [t-2,t-1,t]\n\nfor iipt=1:npts2run\n  ipt = pts2run(iipt);\n  lposGTuse{iipt} = nan(0,2);\n  tposGTuse{iipt} = nan(0,2,3);\n  for iisampGT=1:nGT\n    isamp = isampGT(iisampGT);\n    tMFTwin = tMFTall(isamp-2:isamp,:);\n\n    vmagtmp = pdmi.vmag(isamp-2:isamp-1,ipt);\n    if all(pdmi.ires(isamp-2:isamp)==pdmi.ires(isamp)) && ...\n        all(tMFTwin.mov==tMFTwin.mov(1)) && ...\n        all(tMFTwin.iTgt==tMFTwin.iTgt(1)) && ...\n        isequal(tMFTwin.frm,(tMFTwin.frm(1):tMFTwin.frm(3))') && ...\n        all(vmagtmp(:)>VMAG_MINOKTHRESH)\n      lposGTuse{iipt}(end+1,:) = lposGT(iisampGT,ipt,:);\n      tmp = pdmi.x(isamp-2:isamp,ipt,:);\n      tmp = reshape(tmp,3,2)';\n      tposGTuse{iipt}(end+1,:,:) = tmp;\n    else\n      warningNoTrace('iissampGT=%d, skipping, not enough precursors or vmag too small.',iisampGT);\n    end\n  end\n\n  fprintf('iipt=%d,ipt=%d\\n',iipt,ipt);  \n  size(lposGTuse{iipt})\n  size(tposGTuse{iipt})\n  errGT = lposGTuse{iipt}-tposGTuse{iipt}(:,:,3);\n  errGT = sqrt(sum(errGT.^2,2));\n  mean(errGT)\n  \n  pause(5);\nend\n\n%%\nnpts2run = numel(pts2run);\ntformpts = cell(npts2run,1);\n% tformpts{iipt} = nan(nuse,2,4); % tformed pts. 4th dim: t-2,t-1,t,lbl\nfor iipt=1:npts2run\n  ipt = pts2run(iipt);\n  \n  nuse = size(lposGTuse{iipt},1);\n  tformpts{iipt} = nan(nuse,2,4);\n\n  for iuse=1:nuse\n    if mod(iuse,10)==1\n      disp(iuse);\n    end\n    \n    lpos = lposGTuse{iipt}(iuse,:);\n    tpos = squeeze(tposGTuse{iipt}(iuse,:,:));\n    tpos = tpos';\n    szassert(lpos,[1 2]);\n    szassert(tpos,[3 2]);\n    \n    if ~isequal(tpos(1,:),tpos(2,:))\n      tform = fitgeotrans(tpos(1:2,:),[0 0;0 1],'nonreflectivesimilarity');\n      xypts = [tpos; lpos];\n      szassert(xypts,[4 2]);\n      \n      xytform = tform.transformPointsForward(xypts);\n      tformpts{iipt}(iuse,:,:) = xytform';\n    else\n      warningNoTrace('iuse %d, ipt %d. tpos1 and tpos2 are identical (v=0). cannot reproject',iuse,ipt);\n    end\n    \n  end\nend\n%%\nhFig = figure(11);\nclf;\naxs = mycreatesubplots(2,npts2run,[.1 .05;.1 .05]);\nfor iipt=1:npts2run\n  ipt = pts2run(iipt);\n  \n  nuse = size(tformpts{iipt},1);\n  fprintf('\\niipt=%d, ipt=%d, nuse=%d\\n',iipt,ipt,nuse);\n  \n  xy = squeeze(tformpts{iipt}(:,:,3)); % trk at t  \n  ifo = GTPlot.gaussianFit(xy);  \n  fprintf('ipt=%d. gaussian fit trk@t. mean: %s\\n',pts2run(iipt),mat2str(ifo.mean,3));\n  fprintf('ipt=%d. trk@t. y median: %s\\n',pts2run(iipt),num2str(median(xy(:,2)),3));\n  %[v,d] = eig(ifo.cov)\n\n  xy = squeeze(tformpts{iipt}(:,:,4)); % lbl at t  \n  ifolbl = GTPlot.gaussianFit(xy);\n  fprintf('ipt=%d. gaussian fit lbl@t. mean: %s\\n',pts2run(iipt),mat2str(ifolbl.mean,3));\n  fprintf('ipt=%d. lbl@t. y median: %s\\n',pts2run(iipt),num2str(median(xy(:,2)),3));\n  %[v,d] = eig(ifolbl.cov)\n  \n  ax = axs(1,iipt);\n  axes(ax)\n  %plot(tformpts(:,iipt,1,3),tformpts(:,iipt,2,3),'r.');\n  s = scatterhistogram(tformpts{iipt}(:,1,3),tformpts{iipt}(:,2,3));\n  s.XLimits = [-25 25];\n  s.YLimits = [-25 25];\n  %grid on;\n  \n  ax = axs(2,iipt);\n  axes(ax)\n  %plot(tformpts(:,iipt,1,4),tformpts(:,iipt,2,4),'r.');\n  s = scatterhistogram(tformpts{iipt}(:,1,4),tformpts{iipt}(:,2,4));\n  s.XLimits = [-25 25];\n  s.YLimits = [-25 25];\n  %grid on;  \nend\n%linkaxes(axs(:));\n%axis equal square\n\n\n%% AC cost vs Motion cost\n\n%x = pdall.maxdensity_indep.x;\n\n% figure out typical scale of heatmap/ac\n[nmax,IRES] = max([res.N]);\n%IRES = 1;\npp = res(IRES);\nnfrm1 = pp.N;\nfprintf(1,'Looking at heatmaps using pp/res idx=%d with N=%d.\\n',IRES,nfrm1);\nhm_hwhm = nan(nfrm1,npts2run); % half-width-half-max (radius of heatmap dist at half-max)\nhm_atmax = nan(nfrm1,npts2run);\nhmgrid = pp.heatmapdata.grid{1}; % rows are linear indices, cols are [x y]\nfor f=1:nfrm1\n  if mod(f,10)==0, disp(f); end\n  for iipt=1:npts2run\n    ipt = pp.pts2run(iipt);\n    hm = pp.ReadHeatmapScore(ipt,1,f); % double in [0,1]\n    [hmmax,hmmaxidx] = max(hm(:));\n    hmmax_xy = hmgrid(hmmaxidx,:);\n    hmnzidx = find(hm(:)>0);\n    hmnz = hm(hmnzidx);\n    hmnz_xy = hmgrid(hmnzidx,:); \n    hmnz_dxy = hmnz_xy-hmmax_xy;\n    hmnz_r = sqrt(sum(hmnz_dxy.^2,2)); % dist from nz hm point to hm peak/max\n    hmnz_r = round(hmnz_r);\n    assert(isequal(size(hmnz),size(hmnz_r)));\n    \n    hm_atmax(f,ipt) = hmmax;\n    \n    % for each hmnz_r, find the average hmnz\n    hmnz_rgt0 = hmnz(hmnz_r>0);\n    hmnz_r_rgt0 = hmnz_r(hmnz_r>0);\n    hmnz_r_meanmag = accumarray(hmnz_r_rgt0,hmnz_rgt0,[],@mean);\n    \n    rhwhm = find(hmnz_r_meanmag<hmmax/2,1);\n    hm_hwhm(f,ipt) = rhwhm;\n  end\nend\n    \n%% MC distribs\nnpts2run = numel(pp.pts2run);\nhFig = figure(12);\nclf;\naxs = mycreatesubplots(1,2,[.1 .05;.1 .05]);\n\nylblargs = {'fontweight' 'bold' 'interpreter' 'none'};\n%DXFLDS = {dxmag_pred dxmag_pred_a2};\nDXFLDNAMES = {'dx_pred_mag'};\nfor iDx=1:numel(DXFLDNAMES)\n  fld = DXFLDNAMES{iDx};\n  dxmag = pdall.maxdensity_indep.(fld);\n%  dxmag = DXFLDS{iDx};\n%   %DXdxmag = pdmi.(fld); % n x npt\n  dxmag2 = dxmag.^2;\n  \n  ax = axs(iDx);\n  axes(ax)\n  boxplot(dxmag(:,pp.pts2run),'labels',pp.pts2run);\n  grid on;\n  title(fld,'fontweight','bold','interpreter','none');\n  \n  ax = axs(iDx+1);\n  axes(ax)\n  boxplot(dxmag2(:,pp.pts2run),'labels',pp.pts2run);\n  grid on;\n  title(sprintf('%s^2',fld),'fontweight','bold','interpreter','none');\n  \n%   for iipt=1:npts2run\n%     ipt = pp.pts2run(iipt);\n%     ax = axs(iDx,iipt);\n%     axes(ax);\n%     histogram(dxmag(:,ipt));    \n%     if iipt==1\n%       ylabel(fld,ylblargs{:});\n%     end\n%     \n%     ax = axs(iDx+2,iipt);\n%     axes(ax);\n%     histogram(dxmag2(:,ipt),100);        \n%     if iipt==1\n%       ylabel(sprintf('%s^2',fld),ylblargs{:});\n%     end\n%   end\nend\n%linkaxes(axs(1:2));\n%% AC distribs (silly)\n\nhFig = figure(14);\nclf;\naxs = mycreatesubplots(3,npts2run,[.1 .05;.1 .05]);\n\nfor iipt=1:npts2run\n  ipt = pp.pts2run(iipt);\n  \n%   zmean = mean(pp.sampledata.z(:,ipt));\n%   zmedn = median(pp.sampledata.z(:,ipt));\n%   fprintf(2,'Your mean zfac is: %.3f\\n',zmean);\n%   fprintf(2,'Your median zfac is: %.3f\\n',zmedn);\n\n  ax = axs(1,iipt);\n  axes(ax);\n  histogram(hm_hwhm(:,ipt));\n  if iipt==1\n    ylabel('hmap_hwhm',ylblargs{:});\n  end\n  \n  ax = axs(2,iipt);\n  axes(ax);\n  histogram(hm_atmax(:,ipt));\n  if ipt==1\n    ylabel('max hm',ylblargs{:});\n  end\n  \n  ax = axs(3,iipt);\n  axes(ax);\n  % diff between AC cost at half-max and at max\n  histogram( -log(hm_atmax(:,ipt)/2) + log(hm_atmax(:,ipt)) ,15 );\n  % duh this is just log(2)\n  if iipt==1\n    ylabel('dAC from peak to half',ylblargs{:});\n  end\nend\n\n% for iipt=1:npts2run\n%   linkaxes(axs(1:2,iipt));\n%   linkaxes(axs(3:4,iipt));\n% end\n\n%% dxmag_pred_mag vs vmag\nhFig = figure(17);\nclf\naxs = mycreatesubplots(2,npts2run,[.1 .05;.1 .05]);\nfor iipt=1:npts2run\n  ipt = pp.pts2run(iipt);\n  ax = axs(1,iipt);\n  \n  pdmi = pdall.maxdensity_indep;\n  vmagI = pdmi.vmag(1:end-2,ipt); % vmag(1,:) gives vel from t=1->t=2, which is used to predict x @ t=3\n  dxmag_pred_tmp = pdmi.dx_pred_mag(3:end,ipt);\n  szassert(vmagI,size(dxmag_pred_tmp));\n  binctrs = 0:15;\n  tfcell = arrayfun(@(x)round(vmagI)==x,binctrs,'uni',0);\n  dxmag_pred_binmean = cellfun(@(x)nanmedian(dxmag_pred_tmp(x)),tfcell);\n  \n  scatter(ax,vmagI,dxmag_pred_tmp);\n  hold(ax,'on');\n  plot(ax,binctrs,dxmag_pred_binmean,'r','linewidth',2);\n  ylabel(ax,sprintf('pt%d',ipt));\n  \n  ax = axs(2,iipt);\n  vmagI = pdall.median.vmag(1:end-2,ipt);  \n  dxmag_pred_tmp = pdall.median.dx_pred_mag(3:end,ipt);  \n  szassert(vmagI,size(dxmag_pred_tmp));\n  tfcell = arrayfun(@(x)round(vmagI)==x,binctrs,'uni',0);\n  dxmag_pred_binmean = cellfun(@(x)nanmedian(dxmag_pred_tmp(x)),tfcell);\n  scatter(ax,vmagI,dxmag_pred_tmp);\n  hold(ax,'on');\n  plot(ax,binctrs,dxmag_pred_binmean,'r','linewidth',2);\nend\nlinkaxes(axs(:));\naxis([0 15 0 15]);\n\n%% dxmag_pred_mag vs vmag 2. Compare prederr vs second vel\nhFig = figure(18);\nclf\naxs = mycreatesubplots(2,npts2run,[.1 .05;.1 .05]);\nfor iipt=1:npts2run\n  ipt = pp.pts2run(iipt);\n  ax = axs(1,iipt);\n  \n  pdmi = pdall.maxdensity_indep;\n  vmagI = pdmi.vmag(2:end-1,ipt); % vmag(2,:) gives vel from t=2->3; compare this to prediction error at t=3\n  dxmag_pred_tmp = pdmi.dx_pred_mag(3:end,ipt);\n  szassert(vmagI,size(dxmag_pred_tmp));\n  binctrs = 0:15;\n  tfcell = arrayfun(@(x)round(vmagI)==x,binctrs,'uni',0);\n  dxmag_pred_binmean = cellfun(@(x)nanmedian(dxmag_pred_tmp(x)),tfcell);\n  \n  scatter(ax,vmagI,dxmag_pred_tmp);\n  hold(ax,'on');\n  plot(ax,binctrs,dxmag_pred_binmean,'r','linewidth',2);\n  ylabel(ax,sprintf('pt%d',ipt));\n  \n  ax = axs(2,iipt);\n  vmagI = pdall.median.vmag(2:end-1,ipt);  \n  dxmag_pred_tmp = pdall.median.dx_pred_mag(3:end,ipt);  \n  szassert(vmagI,size(dxmag_pred_tmp));\n  tfcell = arrayfun(@(x)round(vmagI)==x,binctrs,'uni',0);\n  dxmag_pred_binmean = cellfun(@(x)nanmedian(dxmag_pred_tmp(x)),tfcell);\n  scatter(ax,vmagI,dxmag_pred_tmp);\n  hold(ax,'on');\n  plot(ax,binctrs,dxmag_pred_binmean,'r','linewidth',2);\nend\nlinkaxes(axs(:));\naxis([0 15 0 15]);\n\n%% Damping\n% THIS IS SCREWY SUGGESTS MAYBE the motion model should be that the vel \n% predictor only works when there is motion above a certain thresh. Or do a\n% soft ramp etc.\n\nxprederrmag = pdall.maxdensity_indep.dx_preddamps_mag(:,pp.pts2run,:);\n\nszassert(xprederrmag,[Nall npts2run nDamp]);\nxprederrmagAccGTplot = reshape(xprederrmag,[Nall npts2run 1 1 nDamp]);\n\nhFig = figure(25);\nclf;\n[hFig,hAxs] = GTPlot.ptileCurves(xprederrmagAccGTplot,...\n 'hFig',hFig,...\n 'setNames',numarr2trimcellstr(DAMPS),...\n 'ptnames',numarr2trimcellstr(pp.pts2run),...\n 'titleArgs',{'fontweight','bold'});\n\nhFig = figure(26);\nclf;\n[hFig,hAxs] = GTPlot.ptileCurves(xprederrmagAccGTplot,...\n 'hFig',hFig,...\n 'setNames',numarr2trimcellstr(DAMPS),...\n 'ptnames',numarr2trimcellstr(pp.pts2run),...\n 'titleArgs',{'fontweight','bold'},...\n 'ptiles',[15 30 45 60 75] ...\n);\n\nhFig = figure(27);\nclf;\nxprederrsqAccMu = nanmean(xprederrmag,1);\nxprederrsqAccMu = reshape(xprederrsqAccMu,npts2run,nDamp)';\nxprederrsqAccMdn = nanmedian(xprederrmag,1);\nxprederrsqAccMdn = reshape(xprederrsqAccMdn,npts2run,nDamp)';\n\nh = plot(DAMPS(:),xprederrsqAccMu);\nhold on;\nplot(DAMPS(:),5*xprederrsqAccMdn,'.-');\ntitle('prederreq vs damping','fontweight','bold');\ngrid on;\nyl = ylim;\nyl(1) = 0;\nylim(yl);\n\n%% Damping, looking only at bigger velocities\n% SEEMS TO CONCUR\n\npdmi = pdall.maxdensity_indep;\nVMAGMINOKTHRESH = 1;\n\nfor iipt=1:npts2run\n  ipt = pts2run(iipt);\n\n  xprederrmag = squeeze(pdmi.dx_preddamps_mag(:,ipt,:)); % Nall x nDamp\n  vmag = pdmi.vmag(:,ipt);\n  % vmag(1) and vmag(2) are used to generate xpred(3)\n  tfpredok = false(size(vmag));\n  tfpredok(3:end) = vmag(1:end-2)>VMAGMINOKTHRESH & vmag(2:end-1)>VMAGMINOKTHRESH;\n\n  xprederrplot = xprederrmag(tfpredok,:);\n  xprederrplot = reshape(xprederrplot,[nnz(tfpredok) 1 1 1 nDamp]);\n  fprintf(1,'iipt=%d,ipt=%d. %d/%d rows meet velocity requirement.\\n',...\n    iipt,ipt,nnz(tfpredok),numel(tfpredok));\n\n  hFig = figure(29+iipt);\n  clf;\n  [hFig,hAxs] = GTPlot.ptileCurves(xprederrplot,...\n   'hFig',hFig,...\n   'setNames',numarr2trimcellstr(DAMPS),...\n   'ptnames',numarr2trimcellstr(ipt),...\n   'titleArgs',{'fontweight','bold'},...\n   'ptiles',[15 30 45 60 75],...\n    'createsubplotsborders',[.12 0;.12 .12]...\n   );\nend\n%% Damping + GT\n\n\n% tGT = Labeler.lblFileGetLabels(ld);\n% assert(strcmp(tGT.Properties.VariableNames{1},'mov'));\nlbl = ld;\n[tf,loc] = tblismember(tGT,tMFTall,MFTable.FLDSID);\n%frmsGT = tGT.frm(tf);\nisampGT = loc(tf);\nnGT = nnz(tf);\nnpts = lbl.cfg.NumLabelPoints;\nlposGT = reshape(tGT.p(tf,:),[nGT npts 2]);\nfprintf(1,'%d frmsGT.\\n',nGT);\n\ntpos = pdmi.x(isampGT,:,:);\ntpospred = pdmi.x_preddamps(isampGT,:,:,:);\nszassert(tpos,[nGT npts 2]);\nszassert(tpospred,[nGT npts 2 nDamp]);\n\ndxyGT = lposGT-tpos;\ndxyGTmag = sqrt(sum(dxyGT.^2,3)); % [nGT npts]\ndxyGTpred = lposGT-tpospred;\ndxyGTpredmag = sqrt(sum(dxyGTpred.^2,3)); % [nGT npts 1 nDamp]\n\nerrmagplot = cat(5,...\n  reshape(dxyGTpredmag(:,pts2run,:,:),[nGT npts2run 1 1 nDamp]),...\n  dxyGTmag(:,pts2run) );\nsetNames = [arrayfun(@(x)sprintf('dmp%02d'),1:nDamp,'uni',0) {'noMM'}];\n\n[hFig,hAxs] = GTPlot.ptileCurves(errmagplot,...\n  'ptiles',[50 75 90],...\n  'setNames',setNames,...\n  'ptNames',arrayfun(@(x)sprintf('pt%02d',x),pts2run,'uni',0),...\n  'createsubplotsborders',[.05 0;.15 .15]...\n  );\n\n\nerrxyplot = dxyGTpred(:,pts2run,:,:);\nerrxyplot = reshape(errxyplot,[nGT npts2run 2 1 nDamp]);\nDAMPS2RUN = 1:4:nDamp;\nerrxyplot = errxyplot(:,:,:,:,DAMPS2RUN);\nsetNames = arrayfun(@(x)sprintf('dmp%02d',x),DAMPS2RUN,'uni',0);\nim = zeros(60,40);\nI = {im};\nxyLbl = [25 45;25 30;25 15;15 15;15 30;15 45];\n% SEE Also GT+Damp below\n[hFig,hAxs] = GTPlot.bullseyePtiles(errxyplot,I,xyLbl,...\n  'ptiles',[50 75 90],...\n  'setNames',setNames,...\n  'lineWidth',2,...\n  'contourtype','ellipse');\n\n\n%% autocorr\n\nMAXLAG = 20;\nnLag = MAXLAG+1;\n\npdmi = pdall.maxdensity_indep;\nassert(max(pdmi.ires)==numel(res));\n\nxc = []; % [nlag x npts2run x {x,y} x nres]\nvlag1 = []; % [n x npts2run x {x,y} x {t=i,t=i+1}]\nfor ires=1:numel(res)\n  tfres = pdmi.ires==ires;\n  fprintf(1,'ires=%d, %d rows\\n',ires,nnz(tfres));\n  \n  v = pdmi.v(tfres,pts2run,:);\n  vgood = v(1:end-1,:,:); % clip last nan\n  cxkeep = nan(nLag,npts2run);\n  cykeep = nan(nLag,npts2run);\n%   cxkeeprestricted = nan(nLag,npts2run);\n%   cykeeprestricted = nan(nLag,npts2run);\n  for iipt=1:npts2run\n    vx = vgood(:,iipt,1);\n    vy = vgood(:,iipt,2);\n    cx = xcorr(vx,vx);    \n    cy = xcorr(vy,vy);\n\n    n = numel(vx);\n    cxkeep(:,iipt) = cx(n:n+MAXLAG,:);\n    cykeep(:,iipt) = cy(n:n+MAXLAG,:);\n  end\n  \n  xc = cat(4,xc,cat(3,cxkeep,cykeep));\n  \n  vlag1 = cat(1,vlag1,cat(4,vgood(1:end-1,:,:),vgood(2:end,:,:)));\nend\n\n%%\n\nxcsum = sum(xc,4); % sum over all intervals. each sample equally weighted\nnlag = size(xcsum,1);\n\nfigure(31);\nclf;\naxs = mycreatesubplots(npts2run,1,[0.12 0.05;0.12 0.05]);\nx = 0:nlag-1;\nfor iipt=1:npts2run\n  ax = axs(iipt,1);\n  axes(ax);\n  \n  plot(x,xcsum(:,iipt,1)/xcsum(1,iipt,1),'bo-','linewidth',2);\n  hold on;\n  plot(x,xcsum(:,iipt,2)/xcsum(1,iipt,2),'rx-','linewidth',2);\n  grid on;\n  plot(x,zeros(size(x)),'k-');\nend\n\n    \n%% Vlag1 scatter\n\nV_1D_MINOKTHRESHS = 0:2:6;\nJITTERSZ = 0.4;\nnThresh = numel(V_1D_MINOKTHRESHS);\n\n\nhFig = figure(32);\nset(hFig,'name','vlag1 X');\nclf\naxsX = mycreatesubplots(nThresh,npts2run,[0.12 0.05;0.12 0.05]);\n\nhFig = figure(33);\nset(hFig,'name','vlag1 Y');\nclf\naxsY = mycreatesubplots(nThresh,npts2run,[0.12 0.05;0.12 0.05]);\n\naxs = cat(3,axsX,axsY); % [nThresh x npts2run x {x,y}]\n\nfor iThresh=1:nThresh\n  thresh = V_1D_MINOKTHRESHS(iThresh);\n  tfok = all(abs(vlag1)>=thresh,4);\n  \n  for iipt=1:npts2run\n    ipt = pts2run(iipt);\n    \n    assert(size(vlag1,2)==npts2run);\n    vlag1IPTokx = vlag1(tfok(:,iipt,1),iipt,1,:);\n    vlag1IPToky = vlag1(tfok(:,iipt,2),iipt,2,:);\n    vlag1OKs = {vlag1IPTokx vlag1IPToky};\n    \n    nokx = size(vlag1IPTokx,1);\n    noky = size(vlag1IPToky,1);\n    fprintf(1,'thresh=%f, ipt=%d, nokx/noky=%d/%d.\\n',thresh,ipt,nokx,noky);\n    nOKs = {nokx noky};\n    % for xy=1:2\n    %   ax = axs(xy);\n    %   axes(ax);\n    %   xscat = vlag1(:,IIPT,xy,1);\n    %   yscat = vlag1(:,IIPT,xy,2);\n    %   p1 = polyfit(xscat,yscat,1);\n    %   p3 = polyfit(xscat,yscat,3);\n    %   [r p] = corrcoef(xscat,yscat);\n    %   xbins = -30:30;\n    %   ybins = arrayfun(@(x)median(yscat(round(xscat)==x)),xbins);\n    %   xscat = xscat+JITTERSZ*2*(rand(size(xscat))-0.5);\n    %   yscat = yscat+JITTERSZ*2*(rand(size(yscat))-0.5);\n    %   plot(xscat,yscat,'.');\n    %   tstr = sprintf('linear: slope=%.3g r=%.3g p=%.3g',p1(1),r(1,2),p(1,2));\n    %   hold on;\n    %   x = -30:1:30;\n    %   y1 = p1(1)*x+p(2);\n    %   y3 = p3(1)*x.^3 + p3(2)*x.^2 + p3(3)*x.^1 + p3(4);\n    %   plot(x,y1,'r-',x,y3,'r-','linewidth',2);\n    %   plot(xbins,ybins,'rs','markerfacecolor',[1 0 0]);\n    %   title(tstr);\n    %   grid on\n    %   axis([-30 30 -30 30]);\n    % end\n    % linkaxes(axs);\n\n    for xy=1:2\n      ax = axs(iThresh,iipt,xy);\n      axes(ax);\n      \n      vlagmat = vlag1OKs{xy};\n      nok = nOKs{xy};\n      \n      xscat = vlagmat(:,1,1,1);\n      yscat = vlagmat(:,1,1,2);\n      p1 = polyfit(xscat,yscat,1);\n      p3 = polyfit(xscat,yscat,3);\n      [r p] = corrcoef(xscat,yscat);\n      xbins = -30:30;\n      ybins = arrayfun(@(x)median(yscat(round(xscat)==x)),xbins);\n      xscat = xscat+JITTERSZ*2*(rand(size(xscat))-0.5);\n      yscat = yscat+JITTERSZ*2*(rand(size(yscat))-0.5);\n      plot(xscat,yscat,'.');\n      tstr = sprintf('nOK=%d. slope=%.2g r=%.2g p=%.2g',nok,p1(1),r(1,2),p(1,2));\n      hold on;\n      x = -30:1:30;\n      y1 = p1(1)*x+p(2);\n      y3 = p3(1)*x.^3 + p3(2)*x.^2 + p3(3)*x.^1 + p3(4);\n      plot(x,y1,'r-',x,y3,'r-','linewidth',2);\n      plot(xbins,ybins,'rs','markerfacecolor',[1 0 0]);\n      title(tstr);\n      grid on\n      axis([-30 30 -30 30]);\n    end\n  end\nend\n%linkaxes(axs);\n\n%% Viterbigrid xAC\nacmid = pp.viterbi_grid_acradius+1;\n\nhFig = figure(36);\naxs = mycreatesubplots(npts2run,2);\nfor iipt=1:npts2run\n  ipt = pts2run(iipt);\n  for xy=1:2\n    z = pdall.viterbi_grid.xAC(:,ipt,xy);\n    ax = axs(iipt,xy);\n    axes(ax);\n    \n    histogram(z);\n    \n    nmidfar = nnz(z<acmid-1 | z>acmid+1);\n    nmidpm1 = nnz(z==acmid-1 | z==acmid+1);\n    nmid = nnz(z==acmid);\n    fprintf(1,'ipt %d, xy=%d. %.1f %% far from mid, %.1f mid +/-1, %.1f mid.\\n',...\n      ipt,xy,nmidfar/numel(z)*100,nmidpm1/numel(z)*100,nmid/numel(z)*100);\n  end\nend\n    \n    \n  ",
    "timestamp": "2025-05-23T16:23:24.005950",
    "tags": [],
    "severity": "medium",
    "services_affected": [
      "api",
      "web",
      "cache"
    ],
    "root_cause": null,
    "resolution_time": null,
    "infrastructure_components": [
      "azure",
      "postgresql",
      "redis"
    ],
    "failure_pattern": null,
    "timeline_events": [],
    "blast_radius": "global",
    "detection_time": null,
    "mitigation_actions": [
      "space and the central"
    ],
    "quality_score": 0.45
  },
  {
    "source": "github:codesearch",
    "url": "https://github.com/bewest/decoding-carelink/blob/9617c662fa17e9bbf1544602c188040d4d040724/logs/postmortem.stick.log",
    "title": "postmortem.stick.log",
    "content": "INFO:__main__:howdy! I'm going to take a look at your carelink usb stick.\nINFO:link:Link opened serial port: Serial<id=0x7f8896438850, open=True>(port='/dev/ttyUSB0', baudrate=9600, bytesize=8, parity='N', stopbits=1, timeout=0.5, xonxoff=False, rtscts=False, dsrdtr=False)\nINFO:__main__:PROCESS:OPEN:0.019\nINFO:__main__:PROCESS:START:0.189:ProductInfo:0x04\nINFO:__main__:link Stick transmit[None] reader[None] download_i[False] status[None] poll_size[None] poll_i[None] command[<ProductInfo:0x04:size(64)>] processing ProductInfo:0x04)\nINFO:__main__:send_force_read: attempt 0/5 send command, read until we get something within some timeout\nINFO:__main__:link Stick transmit[None] reader[None] download_i[False] status[None] poll_size[None] poll_i[None] command[<ProductInfo:0x04:size(64)>] sending ProductInfo:0x04)\nINFO:root:usb.write.len: 3\n0000   0x04 0x00 0x00                             ...\nDEBUG:__main__:sleeping 0.001\nINFO:root:usb.read.len: 64\nINFO:root:usb.read.raw:\n0000   0x02 0x00 0x03 0x00 0xd9 0x80 0x40 0xa7    ......@.\n0008   0x01 0x91 0x39 0x95 0x29 0x03 0x35 0x35    ..9.).55\n0010   0x34 0x00 0x00 0x00 0x00 0x00 0x00 0x00    4.......\n0018   0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00    ........\n0020   0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00    ........\n0028   0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00    ........\n0030   0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00    ........\n0038   0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00    ........\nINFO:__main__:quit send_force_read, found len: 64 expected 64 after 0 attempts\nTraceback (most recent call last):\n  File \"decocare/stick.py\", line 884, in <module>\n    stick.open( )\n  File \"decocare/stick.py\", line 857, in open\n    log.info('%s' % self.product_info( ))\n  File \"decocare/stick.py\", line 508, in product_info\n    return self.query(ProductInfo)\n  File \"decocare/stick.py\", line 502, in query\n    return self.process( )\n  File \"decocare/stick.py\", line 489, in process\n    ack, response = self.command.respond(raw)\n  File \"decocare/stick.py\", line 68, in respond\n    assert commStatus == 1, ('commStatus: %02x expected 0x1' % commStatus)\nAssertionError: commStatus: 02 expected 0x1\nCommand exited with non-zero status 1\npython decocare/stick.py /dev/ttyUSB0\n\telapsed 0:00.12\n\tuser 0.08\n\tsystem 0.01\n\tCPU 81% (0text+0data 10944max)k\n",
    "timestamp": "2025-05-23T16:23:24.903454",
    "tags": [],
    "severity": "high",
    "services_affected": [
      "web"
    ],
    "root_cause": null,
    "resolution_time": null,
    "infrastructure_components": [],
    "failure_pattern": "network_partition",
    "timeline_events": [],
    "blast_radius": "localized",
    "detection_time": null,
    "mitigation_actions": [],
    "quality_score": 0.7
  }
]